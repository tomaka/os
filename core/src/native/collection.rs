// Copyright (C) 2019  Pierre Krieger
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

use crate::native::traits::{NativeProgram, NativeProgramEvent, NativeProgramMessageIdWrite};

use alloc::{boxed::Box, vec::Vec};
use core::pin::Pin;
use futures::prelude::*;
use hashbrown::HashMap;
use redshirt_syscalls_interface::{MessageId, Pid};

pub struct NativeProgramsCollection<'a> {
    interface_registrations_requests: HashMap<[u8; 32], MessageId>,
    interface_registrations: HashMap<[u8; 32], Pid>,
    events_stream: stream::FuturesUnordered<Pin<Box<dyn Future<Output = ()> + 'a>>>,
}

/// Event generated by a [`NativeProgram`].
pub enum NativeProgramsCollectionEvent<'a> {
    /// Request to emit a message.
    Emit {
        interface: [u8; 32],
        pid: Pid,
        message: Vec<u8>,
        message_id_write: Option<NativeProgramsCollectionMessageIdWrite<'a>>,
    },
    /// Request to cancel a previously-emitted message.
    CancelMessage {
        message_id: MessageId,
    },
    Answer {
        message_id: MessageId,
        answer: Vec<u8>,
    },
    /// Notify that the given [`MessageId`] received using [`interface_message`] is erroneous.
    MessageError {
        message_id: MessageId,
    },
}

pub struct NativeProgramsCollectionMessageIdWrite<'a> {
    collec: &'a mut NativeProgramsCollection<'a>,
}

impl<'a> NativeProgramsCollection<'a> {
    pub fn new() -> Self {
        unimplemented!()
    }

    /// Adds a program to the collection.
    pub fn push(&mut self, pid: Pid, program: impl NativeProgram<'a>) {

    }

    pub fn next_event(&mut self) -> impl Future<Output = NativeProgramsCollectionEvent> {
        future::pending()     // FIXME:
    }

    /// Notify the [`NativeProgram`] that a message has arrived on one of the interface that it
    /// has registered.
    fn interface_message(
        &self,
        interface: [u8; 32],
        message_id: Option<MessageId>,
        emitter_pid: Pid,
        message: Vec<u8>
    ) {
        unimplemented!()
    }

    /// Notify the [`NativeProgram`]s that the program with the given [`Pid`] has terminated.
    pub fn process_destroyed(&mut self, pid: Pid) {
        unimplemented!()
    }

    /// Notify the appropriate [`NativeProgram`] of a response to a message that it has previously
    /// emitted.
    pub fn message_response(&self, message_id: MessageId, response: Vec<u8>) {
        unimplemented!()
    }
}

impl<'a> NativeProgramMessageIdWrite for NativeProgramsCollectionMessageIdWrite<'a> {
    fn acknowledge(self, message_id: MessageId) {
        unimplemented!()
    }
}

/*impl<'a> NativeProgram<'a> for NativeProgramsCollection<'a> {
    type Future = Pin<Box<dyn Future<Output = NativeProgramEvent<Self::MessageIdWrite>> + Send + 'a>>;
    type MessageIdWrite = ;

    fn next_event(&'a self) -> Self::Future {
        Box::
        let events_stream = self.events_stream.lock().await;
    }

    fn interface_message(&self, interface: [u8; 32], message_id: Option<MessageId>, emitter_pid: Pid, message: Vec<u8>);

    fn process_destroyed(&self, pid: Pid) {

    }

    /// Notify the [`NativeProgram`] of a response to a message that it has previously emitted.
    fn message_response(&self, message_id: MessageId, response: Vec<u8>);
}*/
