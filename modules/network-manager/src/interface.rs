// Copyright (C) 2019-2020  Pierre Krieger
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

//! Manages a registered networking interface.

use fnv::FnvBuildHasher;
use hashbrown::HashMap;
use smoltcp::{dhcp::Dhcpv4Client, phy, time::Instant};
use std::{
    collections::BTreeMap,
    convert::TryFrom as _,
    fmt, mem,
    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},
    sync::MutexGuard,
};

/// State machine encompassing an Ethernet interface and the sockets operating on it.
pub struct NetInterfaceState<TSockUd> {
    /// State of the Ethernet interface.
    ethernet: smoltcp::iface::EthernetInterface<'static, 'static, 'static, RawDevice>,

    /// State of the DHCPv4 client, if enabled.
    dhcp_v4_client: Option<Dhcpv4Client>,

    /// If false, we have to report to the user that data is available (if that is the case).
    reported_available_data: bool,

    /// Collection of all the active sockets that currently operate on this interface.
    sockets: smoltcp::socket::SocketSet<'static, 'static, 'static>,

    /// State of the sockets. Maintained in parallel with [`NetInterfaceState`].
    sockets_state: HashMap<SocketId, SocketState<TSockUd>, FnvBuildHasher>,

    /// Future that triggers the next time we should poll [`NetInterfaceState::ethernet`].
    /// Must be set to `None` whenever we modify [`NetInterfaceState::ethernet`] in such a way that
    /// it could produce an event.
    next_event_delay: Option<redshirt_time_interface::Delay>,
}

/// Prototype for a [`NetInterfaceState`] under construction.
pub struct NetInterfaceStateBuilder {
    /// List of IP addresses that this interface will handle.
    ip_addresses: Vec<smoltcp::wire::IpCidr>,
    /// Routing table for the interface.
    routes: smoltcp::iface::Routes<'static>,
    /// MAC address of the device.
    mac_address: [u8; 6],
    /// If true, enable DHCP on this interface.
    dhcp_v4: bool,
}

/// Event generated by the [`NetInterfaceState::next_event`] function.
#[derive(Debug)]
pub enum NetInterfaceEvent<'a, TSockUd> {
    /// Data is available to be sent out by the Ethernet cable.
    ///
    /// Contains a mutable reference of the data buffer. Data can be left in the buffer if
    /// desired.
    EthernetCableOut(&'a mut Vec<u8>),
    /// A TCP/IP socket has connected to its target.
    TcpConnected(TcpSocket<'a, TSockUd>),
    /// A TCP/IP socket has been closed by the remote.
    TcpClosed(TcpSocket<'a, TSockUd>),
    /// A TCP/IP socket has data ready to be read.
    TcpReadReady(TcpSocket<'a, TSockUd>),
    /// A TCP/IP socket has finished writing the data that we passed to it, and is now ready to
    /// accept more.
    TcpWriteFinished(TcpSocket<'a, TSockUd>),
}

/// Internal enum similar to [`NetInterfaceEvent`], except that it is `'static`.
///
/// Necessary because of borrow checker issue.
#[derive(Debug)]
enum NetInterfaceEventStatic {
    EthernetCableOut,
    TcpConnected(SocketId),
    TcpClosed(SocketId),
    TcpReadReady(SocketId),
    TcpWriteFinished(SocketId),
}

/// Active TCP socket within a [`NetInterfaceState`].
pub struct TcpSocket<'a, TSockUd> {
    /// Reference to the interface.
    interface: &'a mut NetInterfaceState<TSockUd>,
    /// Identifier of that socket within [`NetInterfaceState::sockets`].
    id: SocketId,
}

/// State of a socket that we maintain in parallel to its actual state.
struct SocketState<TSockUd> {
    user_data: TSockUd,
    is_connected: bool,
    is_closed: bool,
    read_ready: bool,
    write_ready: bool,
    write_remaining: Vec<u8>,
}

#[derive(Debug, thiserror::Error)]
pub enum ConnectError {
    #[error("No route available for this destination")]
    NoRoute,
}

/// Opaque identifier of a socket within a [`NetInterfaceState`].
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SocketId(smoltcp::socket::SocketHandle);

impl<TSockUd> NetInterfaceState<TSockUd> {
    /// Initializes a new TCP connection which tries to connect to the given
    /// [`SocketAddr`](std::net::SocketAddr).
    pub fn build_tcp_socket(
        &mut self,
        listen: bool,
        addr: &SocketAddr,
        user_data: TSockUd,
    ) -> Result<TcpSocket<TSockUd>, ConnectError> {
        let mut socket = {
            let rx_buf = smoltcp::socket::TcpSocketBuffer::new(vec![0; 1024]);
            let tx_buf = smoltcp::socket::TcpSocketBuffer::new(vec![0; 1024]);
            smoltcp::socket::TcpSocket::new(rx_buf, tx_buf)
        };

        if listen {
            socket.listen(addr.clone()).unwrap();
        } else {
            socket.connect(addr.clone(), 50000).unwrap(); // TODO: assign port better
        }

        let id = SocketId(self.sockets.add(socket));
        self.sockets_state.insert(
            id,
            SocketState {
                user_data,
                is_connected: false,
                is_closed: false,
                read_ready: false,
                write_ready: true,
                write_remaining: Vec::new(),
            },
        );
        self.next_event_delay = None;

        Ok(TcpSocket {
            interface: self,
            id,
        })
    }

    /// Returns an existing TCP socket by its ID.
    pub fn tcp_socket_by_id(&mut self, id: SocketId) -> Option<TcpSocket<TSockUd>> {
        if !self.sockets_state.contains_key(&id) {
            return None;
        }

        Some(TcpSocket {
            interface: self,
            id,
        })
    }

    /// Extract the data to transmit out of the Ethernet cable.
    ///
    /// Returns an empty buffer if nothing is ready.
    pub fn read_ethernet_cable_out(&mut self) -> Vec<u8> {
        let mut device_out_buffer = &mut self.ethernet.device_mut().device_out_buffer;
        self.reported_available_data = false;
        mem::replace(&mut *device_out_buffer, Vec::new())
    }

    /// Injects some data coming from the Ethernet cable.
    ///
    /// Call [`NetInterfaceState::next_event`] in order to obtain the result.
    pub fn inject_interface_data(&mut self, data: impl AsRef<[u8]>) {
        self.ethernet
            .device_mut()
            .device_in_buffer
            .extend_from_slice(data.as_ref());
        self.next_event_delay = None;
    }

    /// Wait until an event happens on the network.
    pub async fn next_event<'a>(&'a mut self) -> NetInterfaceEvent<'a, TSockUd> {
        //log::trace!("Polling interface");

        match self.next_event_static().await {
            NetInterfaceEventStatic::EthernetCableOut => {
                let mut device_out_buffer = &mut self.ethernet.device_mut().device_out_buffer;
                // TODO: wrong with reports
                NetInterfaceEvent::EthernetCableOut(device_out_buffer)
            }
            NetInterfaceEventStatic::TcpConnected(id) => {
                NetInterfaceEvent::TcpConnected(self.tcp_socket_by_id(id).unwrap())
            }
            NetInterfaceEventStatic::TcpClosed(id) => {
                NetInterfaceEvent::TcpClosed(self.tcp_socket_by_id(id).unwrap())
            }
            NetInterfaceEventStatic::TcpReadReady(id) => {
                NetInterfaceEvent::TcpReadReady(self.tcp_socket_by_id(id).unwrap())
            }
            NetInterfaceEventStatic::TcpWriteFinished(id) => {
                NetInterfaceEvent::TcpWriteFinished(self.tcp_socket_by_id(id).unwrap())
            }
        }
    }

    async fn next_event_static(&mut self) -> NetInterfaceEventStatic {
        loop {
            // First, check the out buffer.
            if !self.reported_available_data {
                let mut device_out_buffer = &mut self.ethernet.device_mut().device_out_buffer;
                if !device_out_buffer.is_empty() {
                    self.reported_available_data = true;
                    return NetInterfaceEventStatic::EthernetCableOut;
                }
            }

            // Check whether any socket has changed state.
            for (socket_id, socket_state) in &mut self.sockets_state {
                let mut smoltcp_socket =
                    self.sockets.get::<smoltcp::socket::TcpSocket>(socket_id.0);

                // Check if this socket got connected.
                if !socket_state.is_connected && smoltcp_socket.may_send() {
                    socket_state.is_connected = true;
                    return NetInterfaceEventStatic::TcpConnected(*socket_id);
                }

                // Check if this socket got closed.
                if !socket_state.is_closed && !smoltcp_socket.is_open() {
                    socket_state.is_closed = true;
                    // TODO: also remove from list
                    return NetInterfaceEventStatic::TcpClosed(*socket_id);
                }

                // Check if this socket has data for reading.
                if !socket_state.read_ready && smoltcp_socket.can_recv() {
                    socket_state.read_ready = true;
                    return NetInterfaceEventStatic::TcpReadReady(*socket_id);
                }

                // Continue writing `write_remaining`.
                if smoltcp_socket.can_send() && !socket_state.write_remaining.is_empty() {
                    let written = smoltcp_socket
                        .send_slice(&socket_state.write_remaining)
                        .unwrap();
                    socket_state.write_remaining = socket_state.write_remaining.split_off(written);
                }

                // Report when this socket is available for writing.
                if smoltcp_socket.may_send()
                    && !socket_state.write_ready
                    && socket_state.write_remaining.is_empty()
                {
                    socket_state.write_ready = true;
                    return NetInterfaceEventStatic::TcpWriteFinished(*socket_id);
                }
            }

            // Perform an active wait if any is going on.
            {
                if let Some(next_event_delay) = self.next_event_delay.as_mut() {
                    next_event_delay.await;
                }
                self.next_event_delay = None;
            }

            // Errors, other than `Unrecognized`, are meant to be logged and ignored.
            match self.ethernet.poll(&mut self.sockets, now().await) {
                Ok(_) => {}
                // The documentation of smoltcp recommends to *not* log any `Unrecognized`
                // error, as such errors happen very frequently.
                Err(smoltcp::Error::Unrecognized) => {}
                Err(err) => {
                    log::trace!("Error while polling interface: {:?}", err);
                }
            };

            // Process the DHCPv4 client.
            // TODO: handle `next_poll`
            if let Some(dhcp_v4_client) = &mut self.dhcp_v4_client {
                match dhcp_v4_client.poll(&mut self.ethernet, &mut self.sockets, now().await) {
                    // TODO: is it normal to get Unrecognized packets here?
                    Err(smoltcp::Error::Unrecognized) => {}
                    Err(err) => {
                        log::trace!("Error while polling DHCP client: {:?}", err);
                    }
                    Ok(None) => {}
                    Ok(Some(config)) => panic!("got result: {:?}", config),
                }
            }

            self.next_event_delay = match self.ethernet.poll_delay(&mut self.sockets, now().await) {
                Some(d) => Some(redshirt_time_interface::Delay::new(d.into())),
                None => continue,
            };
        }
    }
}

impl<TSockUd> fmt::Debug for NetInterfaceState<TSockUd> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("NetInterfaceState").finish()
    }
}

impl Default for NetInterfaceStateBuilder {
    fn default() -> Self {
        NetInterfaceStateBuilder {
            ip_addresses: Vec::new(),
            routes: smoltcp::iface::Routes::new(BTreeMap::new()),
            mac_address: [0x01, 0x00, 0x00, 0x00, 0x00, 0x02], // TODO: force config?
            dhcp_v4: true,
        }
    }
}

impl NetInterfaceStateBuilder {
    /// Adds an IP address and submask that this interface is known to handle.
    // TODO: expand description
    // TODO: calling this conflicts with DHCP client
    pub fn with_ip_addr(mut self, ip_addr: IpAddr, prefix_len: u8) -> Self {
        // TODO: check overlap
        match ip_addr {
            IpAddr::V4(addr) => {
                assert!(prefix_len <= 32);
                self.ip_addresses
                    .push(From::from(smoltcp::wire::Ipv4Cidr::new(
                        From::from(addr),
                        prefix_len,
                    )));
            }
            IpAddr::V6(addr) => {
                assert!(prefix_len <= 128);
                self.ip_addresses
                    .push(From::from(smoltcp::wire::Ipv6Cidr::new(
                        From::from(addr),
                        prefix_len,
                    )));
            }
        }

        self
    }

    /// Sets the default gateway to use for IPv4 sockets if no route is available.
    ///
    /// Overwrites the value set by any previous call to this function.
    // TODO: calling this conflicts with DHCP client
    pub fn with_default_ipv4_gateway(mut self, gateway: Ipv4Addr) -> Self {
        self.routes.add_default_ipv4_route(From::from(gateway));
        self
    }

    /// Sets the default gateway to use for IPv4 sockets if no route is available.
    ///
    /// Overwrites the value set by any previous call to this function.
    pub fn with_default_ipv6_gateway(mut self, gateway: Ipv6Addr) -> Self {
        self.routes.add_default_ipv6_route(From::from(gateway));
        self
    }

    /// Sets the MAC address of the device.
    pub fn with_mac_address(mut self, mac: [u8; 6]) -> Self {
        self.mac_address = mac;
        self
    }

    /// Builds the [`NetInterfaceState`].
    pub async fn build<TSockUd>(mut self) -> NetInterfaceState<TSockUd> {
        // TODO: with_capacity?
        let device = RawDevice {
            device_out_buffer: Vec::new(),
            device_in_buffer: Vec::new(),
        };

        self.ip_addresses.shrink_to_fit();

        if self.dhcp_v4 {
            // TODO: conflicts with existing routes?
            self.routes
                .add_default_ipv4_route(smoltcp::wire::Ipv4Address::UNSPECIFIED);
            self.ip_addresses
                .push(From::from(smoltcp::wire::Ipv4Cidr::new(
                    smoltcp::wire::Ipv4Address::UNSPECIFIED,
                    0,
                )));
        }

        let interface = smoltcp::iface::EthernetInterfaceBuilder::new(device)
            .ethernet_addr(smoltcp::wire::EthernetAddress(self.mac_address))
            .ip_addrs(self.ip_addresses)
            .routes(self.routes)
            //.ipv4_multicast_groups(BTreeMap::new())
            .neighbor_cache(smoltcp::iface::NeighborCache::new(BTreeMap::new()))
            .finalize();

        let mut sockets = smoltcp::socket::SocketSet::new(Vec::new());

        let dhcp_v4_client = if self.dhcp_v4 {
            let dhcp_rx_buffer = smoltcp::socket::RawSocketBuffer::new(
                [smoltcp::socket::RawPacketMetadata::EMPTY; 1],
                vec![0; 600],
            );

            let dhcp_tx_buffer = smoltcp::socket::RawSocketBuffer::new(
                [smoltcp::socket::RawPacketMetadata::EMPTY; 1],
                vec![0; 600],
            );

            Some(Dhcpv4Client::new(
                &mut sockets,
                dhcp_rx_buffer,
                dhcp_tx_buffer,
                now().await,
            ))
        } else {
            None
        };

        NetInterfaceState {
            ethernet: interface,
            reported_available_data: false,
            sockets,
            sockets_state: HashMap::default(),
            next_event_delay: None,
            dhcp_v4_client,
        }
    }
}

impl fmt::Debug for NetInterfaceStateBuilder {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("NetInterfaceStateBuilder").finish()
    }
}

impl<'a, TSockUd> TcpSocket<'a, TSockUd> {
    /// Returns the unique identifier of this socket.
    pub fn id(&self) -> SocketId {
        self.id
    }

    /// Starts the process of closing the TCP socket.
    pub fn close(&mut self) {
        let mut socket = self
            .interface
            .sockets
            .get::<smoltcp::socket::TcpSocket<'static>>(self.id.0);
        socket.close();
    }

    /// Instantly drops the socket without a proper shutdown.
    pub fn reset(self) {
        let mut socket = self
            .interface
            .sockets
            .get::<smoltcp::socket::TcpSocket<'static>>(self.id.0);
        socket.abort();
        self.interface
            .sockets_state
            .get_mut(&self.id)
            .unwrap()
            .is_closed = true;
    }

    /// Reads the data that has been received on the TCP socket.
    ///
    /// Returns an empty `Vec` if there is no data available.
    pub fn read(&mut self) -> Vec<u8> {
        let mut socket = self
            .interface
            .sockets
            .get::<smoltcp::socket::TcpSocket<'static>>(self.id.0);
        if !socket.can_recv() {
            return Vec::new();
        }

        self.interface
            .sockets_state
            .get_mut(&self.id)
            .unwrap()
            .read_ready = false;

        let recv_queue_len = socket.recv_queue();
        let mut out = Vec::with_capacity(recv_queue_len);
        unsafe {
            out.set_len(recv_queue_len);
        }
        let n_recved = socket.recv_slice(&mut out).unwrap();
        debug_assert_eq!(n_recved, recv_queue_len);
        debug_assert_eq!(socket.recv_queue(), 0);
        out
    }

    /// Passes a buffer that the socket will encode into Ethernet frames.
    ///
    /// Only one buffer can be active at any given point in time. If a buffer is already active,
    /// returns `Err(buffer)`.
    pub fn set_write_buffer(&mut self, buffer: Vec<u8>) -> Result<(), Vec<u8>> {
        let mut state = self.interface.sockets_state.get_mut(&self.id).unwrap();
        if !state.write_remaining.is_empty() {
            return Err(buffer);
        }

        state.write_ready = false;
        state.write_remaining = buffer;
        Ok(())
    }

    /// Returns a reference to the user data stored within the socket state.
    pub fn user_data(&self) -> &TSockUd {
        let mut state = self.interface.sockets_state.get(&self.id).unwrap();
        &state.user_data
    }

    /// Returns a reference to the user data stored within the socket state.
    pub fn user_data_mut(&mut self) -> &mut TSockUd {
        let mut state = self.interface.sockets_state.get_mut(&self.id).unwrap();
        &mut state.user_data
    }

    /// Internal function that returns the `smoltcp::socket::TcpSocket` contained within the set.
    fn smoltcp_socket(
        &mut self,
    ) -> smoltcp::socket::SocketRef<smoltcp::socket::TcpSocket<'static>> {
        self.interface
            .sockets
            .get::<smoltcp::socket::TcpSocket<'static>>(self.id.0)
    }
}

impl<'a, TSockUd> fmt::Debug for TcpSocket<'a, TSockUd> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_tuple("TcpSocket").field(&self.id()).finish()
    }
}

// TODO: remove?
async fn now() -> smoltcp::time::Instant {
    let now = redshirt_time_interface::monotonic_clock().await;
    smoltcp::time::Instant::from_millis(i64::try_from(now / 1_000_000).unwrap())
}

/// Implementation of `smoltcp::phy::Device`.
struct RawDevice {
    /// Buffer of data to send out to the virtual Ethernet cable.
    device_out_buffer: Vec<u8>,

    /// Buffer of data received from the virtual Ethernet cable.
    device_in_buffer: Vec<u8>,
}

impl<'a> smoltcp::phy::Device<'a> for RawDevice {
    type RxToken = RawDeviceRxToken<'a>;
    type TxToken = RawDeviceTxToken<'a>;

    fn receive(&'a mut self) -> Option<(Self::RxToken, Self::TxToken)> {
        if self.device_in_buffer.is_empty() {
            return None;
        }

        if !self.device_out_buffer.is_empty() {
            return None;
        }

        let rx = RawDeviceRxToken {
            buffer: &mut self.device_in_buffer,
        };
        let tx = RawDeviceTxToken {
            buffer: &mut self.device_out_buffer,
        };
        Some((rx, tx))
    }

    fn transmit(&'a mut self) -> Option<Self::TxToken> {
        if !self.device_out_buffer.is_empty() {
            return None;
        }

        Some(RawDeviceTxToken {
            buffer: &mut self.device_out_buffer,
        })
    }

    fn capabilities(&self) -> phy::DeviceCapabilities {
        let mut caps: phy::DeviceCapabilities = Default::default();
        caps.max_transmission_unit = 9216; // FIXME:
        caps.max_burst_size = None;
        caps.checksum = phy::ChecksumCapabilities::ignored();
        caps.checksum.ipv4 = phy::Checksum::Both;
        caps.checksum.udp = phy::Checksum::Both;
        caps.checksum.tcp = phy::Checksum::Both;
        caps.checksum.icmpv4 = phy::Checksum::Both;
        caps.checksum.icmpv6 = phy::Checksum::Both;
        caps
    }
}

struct RawDeviceRxToken<'a> {
    buffer: &'a mut Vec<u8>,
}

impl<'a> phy::RxToken for RawDeviceRxToken<'a> {
    fn consume<R, F>(mut self, timestamp: Instant, f: F) -> Result<R, smoltcp::Error>
    where
        F: FnOnce(&mut [u8]) -> Result<R, smoltcp::Error>,
    {
        let result = f(&mut self.buffer);
        self.buffer.clear();
        result
    }
}

struct RawDeviceTxToken<'a> {
    buffer: &'a mut Vec<u8>,
}

impl<'a> phy::TxToken for RawDeviceTxToken<'a> {
    fn consume<R, F>(mut self, timestamp: Instant, len: usize, f: F) -> Result<R, smoltcp::Error>
    where
        F: FnOnce(&mut [u8]) -> Result<R, smoltcp::Error>,
    {
        debug_assert!(self.buffer.is_empty());
        *self.buffer = Vec::with_capacity(len);
        unsafe {
            self.buffer.set_len(len);
        }
        f(&mut self.buffer)
    }
}
