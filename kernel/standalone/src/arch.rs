// Copyright (C) 2019-2020  Pierre Krieger
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

//! Platform-specific code and kernel entry point.
//!
//! This module contains all the platform-specific code of the stand-alone kernel, plus the entry
//! point and initialization code.
//!
//! Its main API is a macro called `__gen_boot` whose implementation depends on the platform. This
//! macro, when invoked, generates a bunch of items, including a function exported under the
//! `_start`. It is the role of the user to ensure that this `_start` symbol gets executed once
//! the kernel is loaded in memory.
//!
//! The initialization triggered by the `_start` function (generated by the `__gen_boot` macro)
//! includes:
//!
//! - Initializing all CPU cores.
//! - Setting up a stack for each CPU core.
//! - Setting up the memory allocator in the [`mem_alloc`](crate::mem_alloc) module.
//! - Setting up a panic handler.
//!
//! The `__gen_boot` macro must be passed a function whose signature must be the following:
//!
//! ```
//! async fn(platform_specific: Pin<Arc<arch::PlatformSpecific>>) -> !;
//! ```
//!
//! After the initialization has been performed, this function gets called once per CPU and gets
//! passed an implementation of the [`PlatformSpecific`] trait. If the machine has for example
//! four CPUs, the function gets called four times, once on each CPU.

use core::{
    fmt,
    future::Future,
    num::NonZeroU32,
    pin::Pin,
    task::{Context, Poll},
};
use redshirt_kernel_log_interface::ffi::KernelLogMethod;

#[macro_use]
#[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
#[doc(hidden)]
pub mod arm;
#[macro_use]
#[cfg(any(target_arch = "riscv32", target_arch = "riscv64"))]
#[doc(hidden)]
pub mod riscv;
#[macro_use]
#[cfg(target_arch = "x86_64")]
#[doc(hidden)]
pub mod x86_64;

#[cfg(any(target_arch = "arm", target_arch = "aarch64"))]
use self::arm as plat;
#[cfg(any(target_arch = "riscv32", target_arch = "riscv64"))]
use self::riscv as plat;
#[cfg(target_arch = "x86_64")]
use self::x86_64 as plat;

/// `Future` that fires when the monotonic clock reaches a certain value.
#[pin_project::pin_project]
pub struct TimerFuture(#[pin] plat::TimerFuture);

impl Future for TimerFuture {
    type Output = ();
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {
        self.project().0.poll(cx)
    }
}

/// `Future` that fires when an IRQ is triggered.
#[pin_project::pin_project]
pub struct IrqFuture(#[pin] plat::IrqFuture);

impl Future for IrqFuture {
    type Output = ();
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {
        self.project().0.poll(cx)
    }
}

/// Access to all the platform-specific information.
#[pin_project::pin_project]
pub struct PlatformSpecific(#[pin] plat::PlatformSpecificImpl);

impl PlatformSpecific {
    /// Returns the number of CPUs available.
    pub fn num_cpus(self: Pin<&Self>) -> NonZeroU32 {
        Pin::new(&self.as_ref().0).num_cpus()
    }

    /// Prints a log message. You are strongly encouraged to only use ASCII characters. The
    /// implementation is free to discard any non-supported character.
    pub fn write_log(&self, message: &str) {
        self.0.write_log(message)
    }

    /// Modifies the way logs should be printed. This also influences panics.
    ///
    /// Even if you are not using the logging system, it is important to call this method when for
    /// example the video mode changes, so that the kernel knows how to print panic messages.
    pub fn set_logger_method(&self, method: KernelLogMethod) {
        self.0.set_logger_method(method)
    }

    /// Returns the number of nanoseconds that happened since an undeterminate moment in time.
    ///
    /// > **Note**: The returned value is provided on a "best effort" basis and is not
    /// >           necessarily exact (it is, in fact, rarely exact).
    pub fn monotonic_clock(self: Pin<&Self>) -> u128 {
        Pin::new(&self.as_ref().0).monotonic_clock()
    }

    /// Returns a `Future` that fires when the monotonic clock reaches the given value.
    ///
    /// > **Important**: The returned future is not guaranteed to function properly with an
    /// >                executor other than the ones in the platform-specific code.
    pub fn timer(self: Pin<&Self>, clock_value: u128) -> TimerFuture {
        TimerFuture(Pin::new(&self.as_ref().0).timer(clock_value))
    }

    /// Returns a `Future` that fires the next time the given IRQ is triggered.
    ///
    /// > **Important**: The returned future is not guaranteed to function properly with an
    /// >                executor other than the ones in the platform-specific code.
    // TODO: pass some IRQ number and define what this number exactly means
    pub fn next_irq(self: Pin<&Self>) -> IrqFuture {
        IrqFuture(Pin::new(&self.as_ref().0).next_irq())
    }

    /// Writes a `u8` on a port. Returns an error if the operation is not supported or if the port
    /// is out of range.
    pub unsafe fn write_port_u8(self: Pin<&Self>, port: u32, data: u8) -> Result<(), PortErr> {
        Pin::new(&self.as_ref().0).write_port_u8(port, data)
    }
    /// Writes a `u16` on a port. Returns an error if the operation is not supported or if the
    /// port is out of range.
    pub unsafe fn write_port_u16(self: Pin<&Self>, port: u32, data: u16) -> Result<(), PortErr> {
        Pin::new(&self.as_ref().0).write_port_u16(port, data)
    }
    /// Writes a `u32` on a port. Returns an error if the operation is not supported or if the
    /// port is out of range.
    pub unsafe fn write_port_u32(self: Pin<&Self>, port: u32, data: u32) -> Result<(), PortErr> {
        Pin::new(&self.as_ref().0).write_port_u32(port, data)
    }
    /// Reads a `u8` from a port. Returns an error if the operation is not supported or if the
    /// port is out of range.
    pub unsafe fn read_port_u8(self: Pin<&Self>, port: u32) -> Result<u8, PortErr> {
        Pin::new(&self.as_ref().0).read_port_u8(port)
    }
    /// Reads a `u16` from a port. Returns an error if the operation is not supported or if the
    /// port is out of range.
    pub unsafe fn read_port_u16(self: Pin<&Self>, port: u32) -> Result<u16, PortErr> {
        Pin::new(&self.as_ref().0).read_port_u16(port)
    }
    /// Reads a `u32` from a port. Returns an error if the operation is not supported or if the
    /// port is out of range.
    pub unsafe fn read_port_u32(self: Pin<&Self>, port: u32) -> Result<u32, PortErr> {
        Pin::new(&self.as_ref().0).read_port_u32(port)
    }
}

/// Error when requesting to read/write a hardware port.
#[derive(Debug)]
pub enum PortErr {
    /// Operation is not supported by the hardware.
    Unsupported,
    /// Port is out of range.
    OutOfRange,
}

impl fmt::Display for PortErr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            PortErr::Unsupported => write!(f, "Operation is not supported by the hardware"),
            PortErr::OutOfRange => write!(f, "Port is out of range"),
        }
    }
}
